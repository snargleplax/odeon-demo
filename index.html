<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Odeon - Graph Theatre</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
        }
        h1 {
            color: #e94560;
            margin-bottom: 5px;
        }
        #loading {
            color: #888;
            margin: 20px;
        }
        #stage-container {
            display: none;
            flex-direction: column;
            align-items: center;
            flex: 1;
            min-height: 0;
            width: 100%;
            max-width: 900px;
        }
        #canvas {
            font-family: 'Courier New', monospace;
            font-size: clamp(10px, 2.5vw, 18px);
            line-height: 1.0;
            white-space: pre;
            border: 2px solid #63b3ed;
            border-radius: 8px;
            padding: 10px;
            background: #0d0d1a;
            flex: 1;
            min-height: 0;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            overflow: auto;
            -webkit-overflow-scrolling: touch;
        }
        #canvas-content {
            text-align: left;
            display: inline-block;
            min-width: max-content;
        }
        #info-panel {
            height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        #location {
            color: #e94560;
            font-size: clamp(14px, 2.5vw, 18px);
        }
        #characters {
            color: #4ecdc4;
            font-style: italic;
        }
        #events {
            color: #00d9ff;
            font-style: italic;
            font-size: clamp(11px, 2vw, 14px);
            margin-top: 10px;
            text-align: left;
            max-height: 80px;
            overflow-y: auto;
        }
        .event-item {
            padding: 2px 0;
        }
        #actions {
            margin-top: 15px;
            text-align: left;
            height: 120px;
        }
        #actions h3 {
            color: #888;
            margin: 0 0 10px 0;
            font-size: clamp(11px, 2vw, 14px);
        }
        .action-item {
            color: #aaa;
            padding: 4px 8px;
            font-size: clamp(11px, 2vw, 14px);
            cursor: pointer;
            border-radius: 4px;
        }
        .action-item:hover {
            background: #2a2a4e;
        }
        .action-item.selected {
            color: #ffcc00;
            background: #2a2a4e;
        }
        .action-item.selected::before {
            content: '▶ ';
        }
        #current-action {
            color: #ffcc00;
            font-weight: bold;
            padding: 8px 16px;
            border: 2px solid #ffcc00;
            border-radius: 8px;
            margin: 5px 0;
            min-height: 20px;
        }
        #current-action:empty {
            display: none;
        }
        #controls {
            margin: 10px 0;
            display: flex;
            gap: 10px;
            flex-shrink: 0;
        }
        .control-btn {
            background: #e94560;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: clamp(12px, 2vw, 14px);
            cursor: pointer;
            font-family: 'Courier New', monospace;
            border-radius: 4px;
        }
        .control-btn:hover {
            background: #ff6b6b;
        }
        .control-btn:disabled {
            background: #555;
            cursor: not-allowed;
        }
        #footer {
            position: fixed;
            bottom: 5px;
            right: 10px;
            color: #555;
            font-size: 10px;
        }
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
            h1 {
                margin: 0 0 5px 0;
                font-size: 20px;
            }
            #canvas {
                max-height: 66vh;
            }
            #actions {
                display: none;
            }
            #info-panel {
                height: auto;
                padding: 5px 0;
                flex-shrink: 0;
            }
            #events {
                max-height: 40px;
                flex-shrink: 0;
            }
        }
    </style>
</head>
<body>
    <h1>ODEON</h1>
    <div id="loading">Loading WASM...</div>
    <div id="stage-container">
        <div id="canvas"><div id="canvas-content"></div></div>
        <div id="controls">
            <button class="control-btn" onclick="moveSelectionUp()">▲</button>
            <button class="control-btn" onclick="moveSelectionDown()">▼</button>
            <button id="act-btn" class="control-btn" onclick="executeSelected()">Act</button>
            <button class="control-btn" onclick="actRandom()">Random</button>
            <button class="control-btn" onclick="startNewStory()">New</button>
        </div>
        <div id="current-action"></div>
        <div id="info-panel">
            <div id="location"></div>
            <div id="characters"></div>
        </div>
        <div id="events"></div>
        <div id="actions">
            <h3>Available Actions:</h3>
            <div id="action-list"></div>
        </div>
    </div>
    <div id="footer"></div>

    <script src="wasm_exec.js"></script>
    <script>
        const go = new Go();
        let currentActions = [];
        let selectedIndex = 0;
        let buildInfo = null;

        function ansiToHex(ansi) {
            // Basic 256-color ANSI to hex conversion
            if (!ansi) return null;
            const n = parseInt(ansi, 10);
            if (isNaN(n)) return null;

            // Standard colors (0-15)
            const standard = [
                '#000000', '#800000', '#008000', '#808000', '#000080', '#800080', '#008080', '#c0c0c0',
                '#808080', '#ff0000', '#00ff00', '#ffff00', '#0000ff', '#ff00ff', '#00ffff', '#ffffff'
            ];
            if (n < 16) return standard[n];

            // 216-color cube (16-231)
            if (n < 232) {
                const idx = n - 16;
                const r = Math.floor(idx / 36) * 51;
                const g = Math.floor((idx % 36) / 6) * 51;
                const b = (idx % 6) * 51;
                return `rgb(${r},${g},${b})`;
            }

            // Grayscale (232-255)
            const gray = (n - 232) * 10 + 8;
            return `rgb(${gray},${gray},${gray})`;
        }

        function scrollToActiveChar(frame) {
            if (frame.activeX === undefined) return;
            const canvas = document.getElementById('canvas');
            const content = document.getElementById('canvas-content');

            // Add padding so active character can be centered even at edges/small maps
            const padX = canvas.clientWidth / 2;
            const padY = canvas.clientHeight / 2;
            content.style.padding = `${padY}px ${padX}px`;

            // Calculate pixel position (monospace char width ~= font-size * 0.6)
            const fontSize = parseFloat(getComputedStyle(content).fontSize);
            const charWidth = fontSize * 0.6;
            const charHeight = fontSize;

            const targetX = frame.activeX * charWidth + padX;
            const targetY = frame.activeY * charHeight + padY;

            // Scroll to center active character in view
            canvas.scrollTo({
                left: targetX - canvas.clientWidth / 2,
                top: targetY - canvas.clientHeight / 2,
                behavior: 'smooth'
            });
        }

        function renderFrame(frame) {
            if (frame.error) {
                document.getElementById('canvas-content').textContent = 'Error: ' + frame.error;
                return;
            }

            // Render canvas with colors
            let html = '';
            for (const row of frame.cells) {
                for (const cell of row) {
                    const fg = ansiToHex(cell.fg);
                    const bg = ansiToHex(cell.bg);
                    let style = '';
                    if (fg) style += `color:${fg};`;
                    if (bg) style += `background:${bg};`;

                    const char = cell.char || ' ';
                    const escaped = char.replace(/</g, '&lt;').replace(/>/g, '&gt;');

                    if (style) {
                        html += `<span style="${style}">${escaped}</span>`;
                    } else {
                        html += escaped;
                    }
                }
                html += '\n';
            }
            document.getElementById('canvas-content').innerHTML = html;

            // Update location
            document.getElementById('location').textContent = frame.location || '';

            // Update characters
            if (frame.characters && frame.characters.length > 0) {
                document.getElementById('characters').textContent = frame.characters.join(', ') + ' is here';
            } else {
                document.getElementById('characters').textContent = '';
            }

            // Update events
            const eventsDiv = document.getElementById('events');
            eventsDiv.innerHTML = '';
            if (frame.events && frame.events.length > 0) {
                for (const event of frame.events) {
                    const item = document.createElement('div');
                    item.className = 'event-item';
                    item.textContent = event;
                    eventsDiv.appendChild(item);
                }
            }

            // Update actions with selection highlighting
            currentActions = frame.actions || [];
            selectedIndex = frame.selectedIndex || 0;
            const actionList = document.getElementById('action-list');
            actionList.innerHTML = '';
            if (currentActions.length > 0) {
                for (let i = 0; i < currentActions.length; i++) {
                    const action = currentActions[i];
                    const item = document.createElement('div');
                    item.className = 'action-item' + (i === selectedIndex ? ' selected' : '');
                    item.textContent = action.label;
                    item.onclick = () => selectAction(i);
                    actionList.appendChild(item);
                }
            } else {
                actionList.innerHTML = '<div style="color:#888">(none available)</div>';
            }

            // Enable/disable Act button based on available actions
            document.getElementById('act-btn').disabled = currentActions.length === 0;

            // Scroll to keep active character visible
            scrollToActiveChar(frame);
        }

        let animating = false;

        function moveSelectionUp() {
            if (animating || currentActions.length === 0) return;
            renderFrame(JSON.parse(selectUp()));
        }

        function moveSelectionDown() {
            if (animating || currentActions.length === 0) return;
            renderFrame(JSON.parse(selectDown()));
        }

        function selectAction(index) {
            if (animating) return;
            // Click to select, then user can press Act
            while (selectedIndex !== index) {
                if (selectedIndex < index) {
                    renderFrame(JSON.parse(selectDown()));
                } else {
                    renderFrame(JSON.parse(selectUp()));
                }
            }
        }

        function executeSelected() {
            if (currentActions.length === 0 || animating) return;
            const action = currentActions[selectedIndex];
            executeAction(action);
        }

        function actRandom() {
            if (currentActions.length === 0 || animating) return;
            const randomIndex = Math.floor(Math.random() * currentActions.length);
            const action = currentActions[randomIndex];
            executeAction(action);
        }

        function executeAction(action) {
            // Show what action is being taken
            document.getElementById('current-action').textContent = action.label;

            // Start the move and get path length
            const moveResult = JSON.parse(startMove(action.index));
            if (moveResult.error) {
                console.error(moveResult.error);
                return;
            }

            if (moveResult.pathLength === 0) {
                // No path, already teleported
                renderFrame(JSON.parse(finishMove()));
                return;
            }

            // Animate through the path
            animating = true;
            document.getElementById('act-btn').disabled = true;
            let step = 0;
            const pathLength = moveResult.pathLength;

            function animateStep() {
                if (step < pathLength) {
                    const frame = JSON.parse(animStep(step));
                    renderFrame(frame);
                    step++;
                    setTimeout(animateStep, buildInfo.animStepMs);
                } else {
                    // Animation complete
                    const frame = JSON.parse(finishMove());
                    renderFrame(frame);
                    animating = false;
                }
            }

            animateStep();
        }

        function startNewStory() {
            document.getElementById('current-action').textContent = '';
            const seed = Date.now();
            const result = newPlay(seed);
            renderFrame(JSON.parse(result));
        }

        WebAssembly.instantiateStreaming(fetch("main.wasm"), go.importObject).then((result) => {
            go.run(result.instance);
            document.getElementById('loading').style.display = 'none';
            document.getElementById('stage-container').style.display = 'flex';

            // Start a new story
            startNewStory();

            // Load build info
            buildInfo = JSON.parse(getBuildInfo());
            const shortSHA = buildInfo.gitSHA.substring(0, 7);
            document.getElementById('footer').textContent = shortSHA;

            // Keyboard handlers
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    moveSelectionUp();
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    moveSelectionDown();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    executeSelected();
                } else if (e.key === ' ') {
                    e.preventDefault();
                    actRandom();
                } else if (e.key === 'r' || e.key === 'R') {
                    startNewStory();
                }
            });
        }).catch(err => {
            document.getElementById('loading').textContent = 'Error loading WASM: ' + err;
        });
    </script>
</body>
</html>
